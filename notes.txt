Things to do:

 - separate out concerns using free monads
 - add merging into the top-level, so we can do a combined validate/merge pipeline
 - progress/status reporting via scalajs
 - a http4s API

 ----

What distinct operations are going on in FileValidation?

 - parse the config
 - determine which files are missing / present
 - generate IDs for the files and job
 - record which files are missing
 - validate a file
 - persist row failures

There's a clear split here between database stuff and non-database stuff.

Obvious design glitches:
 - validateFile depends directly on io.file.readAll, should be EOTW
   - changed this so that validateFile is basically just a factory method, I think it's ok for it to to have io.file
     in now
 - initialiseFiles mixes concerns, it's doing DB stuff and file stuff
   - actually, is it just doing DB stuff?
   - split this into checkFilesExist / initialiseJob

----

Next up would be:
 - can I turn the function signatures in FVStreamOps, FVDbOps into algebra + interpreter?

Ok, done the basics of making composable algebras for stream and db, but I think there are other
bits in FileValidation that need turning into a DSL (i.e. parseRequiredFiles and checkFilesExist) before I can
really compose everything together.

----

Fundamental misunderstanding #1 - looks like you can only compose two interpreters
 - so, I think the thing to do here is to build FileValidation on top of StreamOps, and then combine
   the result with DatabaseOps at the top level
 - problem with that being that StreamOps is kind-of dependant on DatabaseOps, so it becomes circular
